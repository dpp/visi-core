/* C style comment here */
/* C style
here */
##comment
## comment
   ## comment
## comment "something". todo.
1 + 2

## add $namespace stuff. check `name $name .name
1#seconds + 1.#minutes  +  1.0#hours +  1#days + 100% - 10 ^ 6 ## 8.9061001E7
3 < 2
3 > 2
3 <= 2
3 >= 2

x = 4  ## #'user/x
y = 3  ## #'user/y
x != y ## true
x <> y ## true
x == y ## false

true && false || false
"string" & "join" ## string join
"stringh" & "join"
x %% y  ##  merge
:xkeyword
re$-matches( #/a.+/, "abc") ## regex
x = 3; x
source xyz = "https://example.com/x.txt"
sink xx = 3
begin ## block code
    x = 4
    x + 1
end
f(x, y) = x + y; f(3,4) ## function def, function call
y = [3, 7, 5] ## vector
{:y -> 7, :b -> 8} ## map

`Math/sin(0.5) ## java stuff
`Math/cos(`Math/PI / 3)
xx = `Math/cos(`Math/PI / 3)

plus_one = x => x + 1
plus_one(x) = x + 1

calc_tax(income) = income * if(income > 5000, 40%, 20%)
tax_rate(income) = if(income > 5000, 40%, 20%)

tax_rate(income) =
  if income > 5000 then
    40%
  else
    20%

calc_tax(income) = income * tax_rate(income)

## In Visi, there are three constructs: expressions, declarations, and housekeeping.

test_income(income) =
  mag = Math/log10(income) ## the magnitude of the income
  if mag < 3 then "low"
  else if mag < 5 then "med"
  else "high"

## Functions and Big Data
##Let's look at an example of computing the average of a collection of numbers using map/reduce:

data = [1000, 10, 250000, 33]
mapped = map(identity, data)
reduced = reduce((acc, data) =>
                  merge-with((+), ## Merge the accumulator and the current value
                   acc, ## The accumulator
                  {:cnt -> 1, ## The data to add to the accumulator
                   :sum -> data}),
                  {}, ## Starting value for the acculumator
                  mapped) ## The data to reduce

average = reduced.sum / reduced.cnt

##The above code applies the "identity" function to each element in the set. The identity function returns the same value it took. So, the mapping phase results in the same collection that was input.

data = [1000, 10, 250000, 33] ## The data set

mapped = map(# Math/log10(it), data) ## Don't change the elements

reduced = reduce((acc, data) =>
                  merge-with((+), ## Merge the accumulator and the current value
                   acc, ## The accumulator
                  {:cnt -> 1, ## The data to add to the accumulator
                   :sum -> data}),
                  {}, ## Starting value for the acculumator
                  mapped) ## The data to reduce

average = reduced.sum / reduced.cnt

##Map/Reduce jobs can contain many map and reduce phases. Visi makes it really simple to define the pipeline as a series of function definitions and chaining operations.

##We can rewrite the above with:

data = [1000, 10, 250000, 33] ## The data set

reduced = data |>
          map # Math/log10(it) |>
          reduce {} -> (acc, data) => merge-with((+), acc, {:cnt -> 1,
                                                            :sum -> data})

average = reduced.sum / reduced.cnt

##Okay, so we've looked a little at Visi syntax... but let's get to Big Data Hello World... word count.

## split into words
split_words = |> map # re-replace(it, #/\W/, " ") ## Replace non-words with spaces
              |> flatmap # re-seq(#/\w+/, it) ## Split by words

## Count the words
count_words = |> reduce #2 update-in(it1, [it2], incr)

source words = ["some words", "some more words"]

sink counted = words >> split_words >> count_words
