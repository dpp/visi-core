#+TITLE:Why Visi?
#+AUTHOR: David Pollak
#+EMAIL: feeder.of.the.bears@gmail.com
#+BABEL: :session *Clojure* :cache yes :results output graphics :exports both :tangle yes

* Why Visi?
** What is Visi?

Visi is a computer language that allows expression of big data jobs
in a syntax that's not frightening to people familiar with Excel formula functions.
There is more in Visi than there is in Excel formula functions,
but the "more" is adding to what's in Excel.

Let's start with a simple expression... a thing that executes
code and returns a value:

#+BEGIN_SRC visi
 1 + 1
#+END_SRC

That's simple, the expression evaluates to src_visi{1 + 1}. Yay!

In Excel, each cell is a variable... something that can contain
a value. In Excel, cells can be constants (values that do not change)
or formulas. If a cell contains a formula and that formula refers
to another cell, when the predicate cell's value changes, all
the dependent cells update their values.

In Visi, you name the placeholders for values. They are called variables.
So, to create a variable:

#+BEGIN_SRC visi

x = 5

y = x + 5

#+END_SRC


The above code created variables named "x" and "y". "x" is a constant
and "y" is dependent on "x".

In Visi and Excel, you can apply a function to a value:

#+NAME: sin
#+BEGIN_SRC visi :exports both

Math::sin(0.5)

#+END_SRC

Computes to:

#+RESULTS: sin
: 0.479425538604203


In Excel, there are lots and lots of different functions. They are
all in the same group, although the user interface (Insert Function)
lets you pick
functions from categories like "Statistical" or "Financial".

In Visi, functions are grouped in separate packages so that it's easier
to find a function you're looking for and sometimes, like in the
above example, we have to be explicit about which package the
function lives in. The =::= between =Math= and =sin= tells Visi
to look in the =Math= package for the function.

With Visi, you can use any Java package as part of your Visi notebook.
We will cover Java "Host Interoperability" and how to load Java JAR
files into your Visi notebook later in this document.

A declaration is the association of a value with a name
such that the named declaration (variable) can be accessed
by other parts of your notebook. For example:

#+NAME: cos_third_pi
#+BEGIN_SRC visi :export both

Math::cos(Math::PI / 3) ## expression

cos_third_pi = Math::cos(Math::PI / 3) ## declaration

cos_third_pi ## referencing the variable

#+END_SRC

#+RESULTS: cos_third_pi
: (0.5000000000000001 0.5000000000000001)


In Visi, you can create your own functions. So you can use
the same logic in many places without having to copy/paste that logic
over and over:

#+BEGIN_SRC visi

calc_tax(income) = income * if(income > 5000, 40%, 20%)

#+END_SRC

The above function computes the tax amount depending on the income level.

And functions can call other functions:

#+BEGIN_SRC visi

tax_rate(income) = if(income > 5000, 40%, 20%)

calc_tax(income) = income * tax_rate(income)

#+END_SRC

Visi syntax can span multiple lines and if/then/else can be
a formula and it has its own syntax that might be easier to read:

#+BEGIN_SRC visi

tax_rate(income) =
  if income > 5000 then
    40%
  else
    20%

calc_tax(income) = income * tax_rate(income)

#+END_SRC

And Visi code can contain comments so that you and others who
read the code can understand what's going on:

#+BEGIN_SRC visi

tax_rate(income) =
  if income > 5000 then
    40% ## for high incomes
  else
    20% ## for lower incomes

calc_tax(income) = income * tax_rate(income)

#+END_SRC

To summarize, Visi syntax is a lot like Excel syntax, but
there are extensions to what you are familiar with in Excel to
make writing more complex Visi notebooks easier.

** Core Concepts

In Visi, there are three constructs: expressions, declarations,
and housekeeping.

An expression is a value that's computed.
Expressions can evaluate to either values or functions. Or
more precisely, functions are values just like numbers and
strings and collections.

What's a collection? It's a group of other values. For example:

#+BEGIN_SRC visi
[1, 2, 3, 4]
#+END_SRC

Is a collection of numbers. The specific collection type is
called a =Vector=. It's a 1 dimensional ordered array of values.
Ordered means that the Vector retains the elements in the
order that it was originally created

Visi also supports sets. Sets are unordered collections
that contain unique values. So:

#+NAME: a-set
#+BEGIN_SRC visi :exports both
#{"foo", "bar", "baz", "foo", "dog", "dog", "baz"}
#+END_SRC

Only contains 4 elements:

#+RESULTS: a-set
: #{"foo" "bar" "dog" "baz"}

Another collection is a map. A map is an association
between unique keys and values. Both the keys and values
can be any Visi value. Let's create a map of people and
ages:

#+BEGIN_SRC visi
{"David" 51, "Archer" 11, "Tessa" 2}
#+END_SRC

#+RESULTS:
: {"Archer" 11, "Cat" 2, "David" 51}

Note that like sets, the keys are unordered.

If you are familiar with [[http://en.wikipedia.org/wiki/JavaScript][JavaScript]],
maps in Visi are like Objects in JavaScript... collections of
key/value pairs.

Visi also has a =keyword= type. Keywords are handy for
giving a common/shared name to a value in a map. For example:

#+BEGIN_SRC visi
[{:name "David", :type "Human", :age 51},
 {:name "Archer", :type "Dog", :age 11},
 {:name "Tessa", :type "Cat", :age 2}]
#+END_SRC

#+RESULTS:
: [{:age 51, :name "David", :type "Human"} {:age 11, :name "Archer", :type "Dog"} {:age 2, :name "Tessa", :type "Cat"}]

In Visi, functions are values just like strings and numbers and
keywords.
The declaration of a function is just fancy syntax, both of
the following declarations mean the same thing (don't worry about the
function expression syntax for the moment):

#+NAME: plus_one
#+BEGIN_SRC visi :exports both

plus_one = x => x + 1

another_plus_one(x) = x + 1

z = 99

plus_one(z) == another_plus_one(z)

#+END_SRC

Are the two functions the same?

#+RESULTS: plus_one
: true

The first example, assigns the expression =x => x + 1= to =plus_one=. That
expression evaluates to a function. The second example does the same thing
with different syntax. The latter is "syntactic sugar" for the former.

You may be asking, "why do you have more than one way to say the same thing?"
Good question. Visi creates syntactic sugar to give you a more concise
or more natural way of expressing the same code. In different contexts,
the different syntax may seem more natural. For example, the first
declaration looks kind of odd where the second looks like the way we
learned functions in math class. We will get to some examples of passing
functions as parameters in a little while.

In Visi, top level variables (those variables defined outside
another variable declaration) can be accessed by any expression
in a Visi notebook, just like values in cells in Excel.

*** But why functions?

Functions take parameters and perform operations
on the parameters and return a value.

You're familiar with fom

#+NAME: first-example
#+BEGIN_SRC visi :export both


residents = ## Who lives with us?
 [{:name "David", :type "Human", :age 51},
 {:name "Archer", :type "Dog", :age 11},
 {:name "Tessa", :type "Cat", :age 2}]

get_age(r) = get(r, :age)

ages = ## Get the ages
  map(get_age, residents)

ages
#+END_SRC

#+RESULTS: first-example
: (51 11 2)

You can also declare variables that are only visible to expressions
that come after the declaration in the expression. This allows
you to compute an expression and use the result in many
places within a larger expression. For example:

#+BEGIN_SRC visi

test_income(income) =
  mag = Math::log10(income) ## the magnitude of the income
  if mag < 3 then "low"
  else if mag < 5 then "med"
  else "high"



#+END_SRC

We compute the value of "mag" and then reference that
variable in the if/then/else tests.

** Functions and Big Data

Most Big Data processing is done based on a paradigm called "map/reduce".
The paradigm takes a big pile of data and applies the same operation
to each element of the data "mapping" or transforming each element of
data. Then the collection of "mapped" data is "reduced" to an answer
aggregating the mapped data in a "reduce" function.

There is no state or other information shared between each call to the map
function. This means that the map function can be run simultaneously on
many different computers for different elements in the data set. Depending on
the mathematical properties of the reduce phase, that phase may be
run on different computers as well.

Let's look at an example of computing the average of a collection of
numbers using map/reduce:

#+BEGIN_SRC visi

data = [1000, 10, 250000, 33] ## The data set

mapped = map(identity, data) ## Don't change the elements

reduced = reduce((acc, data) =>
                  merge-with((+), ## Merge the accumulator and the current value
                   acc, ## The accumulator
                  {:cnt -> 1, ## The data to add to the accumulator
                   :sum -> data}),
                  {}, ## Starting value for the acculumator
                  mapped) ## The data to reduce

average = reduced.sum / reduced.cnt

#+END_SRC

The above code applies the "identity" function to each element in the
set. The identity function returns the same value it took. So, the
mapping phase results in the same collection that was input.

FIXME -- explain reduce

#+BEGIN_SRC visi

data = [1000, 10, 250000, 33] ## The data set

mapped = map(# `Math/log10(it), data) ## Don't change the elements

reduced = reduce((acc, data) =>
                  merge-with((+), ## Merge the accumulator and the current value
                   acc, ## The accumulator
                  {:cnt -> 1, ## The data to add to the accumulator
                   :sum -> data}),
                  {}, ## Starting value for the acculumator
                  mapped) ## The data to reduce

average = reduced.sum / reduced.cnt

#+END_SRC

FIXME

Map/Reduce jobs can contain many map and reduce phases. Visi makes it really
simple to define the pipeline as a series of function definitions and
chaining operations.

We can rewrite the above with:

#+BEGIN_SRC visi

data = [1000, 10, 250000, 33] ## The data set

reduced = data |>
          map # Math/log10(it) |>
          reduce {} -> (acc, data) => merge-with((+), acc, {:cnt -> 1,
                                                            :sum -> data})

average = reduced.sum / reduced.cnt

#+END_SRC

Okay, so we've looked a little at Visi syntax... but let's get to
Big Data Hello World... word count.

#+BEGIN_SRC visi

## split into words
split_words = |> map # re-replace(it, #/\W/, " ") ## Replace non-words with spaces
              |> flatmap # re-seq(#/\w+/, it) ## Split by words

## Count the words
count_words = |> reduce #2 update-in(it1, [it2], incr)

source words = ["some words", "some more words"]

sink counted = words >> split_words >> count_words

#+END_SRC
